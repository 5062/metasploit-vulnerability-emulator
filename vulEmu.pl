
use JSON;
use Data::Dumper;
use IO::Socket;
use IO::Select;
use IO::Socket::INET;
use IO::Socket::SSL;
use Try::Tiny;
use MIME::Base64;
use IO::Compress::Gzip qw(gzip);
use Compress::Zlib qw(crc32);
use Storable qw(dclone);
use FindBin qw($Bin);
use Time::HiRes qw( gettimeofday );

no warnings 'deprecated';
my $isWin = 0;
if ($^O =~ /mswin/i) { $isWin = 1;}

require "$Bin/userFuncs.pl";
my $CONNECT = 1;
my $DATA    = 2;
my $serviceType = {};
my $cfg;
my $srvSocks = {};
my $sock2module = {};
my $isSrvSock = {};
my $isSSLSock = {};
my $port2module = {};
my $ctx       = {};
my $refs      = {};
my $e;
my $saved;
my $sock;
my $keyFields = {desc => 1, comment => 1 };
my $sendFile = "";
my $lastSock = "";
my $ftpDataSock = "";
my $pendingAction = []; 
my $meteSock;
my $meteState = 0;
my $isServerTypeSet = 0;
my $recvedMetepreterData = 0;
my $defaultPorts = {};
my $peerHost;
my $ctype;
my $debug = 0;
my $lastTS = time();
my $globConfig = {};
my $contentTypes = {
	"png" => "image/png",
	"gif" => "image/gif",
	"ico" => "image/x-icon",
	"svn" => "image/svg+xml",
	"css" => "text/css",
	"js"  => "text/javascript",
	"html"=> "text/html"
};
my $param2func = {
	"http.authorization.basic" => \&getBasicAuth,
	"http.uri" => \&getUri
};
my $knownHeaders = {
	"server" => "Server",
	"location" => "Location",
	"cookie" => "Set-Cookie",
	"authenticate" => "WWW-Authenticate"
	};
my $savedActCmd; #reactivate module after reloading service file
my @pendingActions;
my $sessions = {};
my @results = (); #matched pieces from regex match, 
$dataBuf = "";

my $s = IO::Select->new();
my $s2 = IO::Select->new(); #test if a socket is SSL
use threads ('yield',
			 'stack_size' => 64*4096,
			 'exit' => 'threads_only',
			 'stringify');
use threads::shared;
my $threadVar :shared;
my $thr;
if ($isWin) {
	$thr = threads->create('input_thread');
} else {
	$s->add(\*STDIN);
}
readCfg();
my @a;
my $showData = 0;
my $lhost = "127.0.0.1";
my $extraCmd = "";
for ($i=0; $i<=$#ARGV; $i++) {
	if ($ARGV[$i] eq "set") {
		@a = split(/:/, $ARGV[$i+1], 2);
		$extraCmd = "set $a[0] $a[1]";
		$i ++;
	} elsif ($ARGV[$i] eq "show") {
		$showData = 1;
	} elsif ($ARGV[$i] eq "ip") {
		$lhost = $ARGV[$i+1]; $i++;
		print "lhost is now $lhost\n";
	} elsif ($ARGV[$i] eq "act") {
		processCmd("act " . $ARGV[$i+1], 1);
		$i++;
	} elsif ($ARGV[$i] eq "debug") {
		$debug = $ARGV[$i+1];
		$i ++;
	} 
	
}
if ($extraCmd ne "") { processCmd($extraCmd);}
#print Dumper($cfg);
my $ctrlSrvSock = IO::Socket::INET->new( Proto    => 'tcp',
                                 LocalPort => 65532,
								Reuse     => 1,
                                Listen    => 500
   ) || die "failed to setup ctrl $@\n";
$s->add($ctrlSrvSock);
my $ctrlSock;
my $client;
my $len;
my $isTlv;
my $buff;
my %allServices;
my $lastTs = 0.0;
$| = 1;
print ">>";
while (1) {
	@readySocks = mySelect(0.5);
	checkDelayedJob();
	if ($isWin) {
		if ($threadVar ne "") {
			processCmd($threadVar);
			$threadVar = "";
		}
	}
	foreach $sock (@readySocks) {
		if ($isWin == 0) {
			if ($sock eq \*STDIN) {
				chomp($cmd = <STDIN>);
				processCmd($cmd);
				print ">>";
				next;
			}
		}
		#printf "sock=$sock|$meteSock| %d\n", $sock->sockport();
		if ($ctrlSrvSock eq $sock) {
			$ctrlSock = $sock->accept();
			$s->add($ctrlSock);
		} elsif ($ctrlSock eq $sock) {
			$buff = "";
			recv($sock, $buff, 0x10000,0);
			$len = length($buff);
			#print "len=$len\n";
			if (length($buff) <= 0) {
				$s->remove($sock);
				close $sock;
				next;
			}
			if ($buff eq "\n") { next;}
			#print "$buff\n";
			processCmd($buff, 1);
		} elsif (defined $isSrvSock->{$sock}) {
			$client = $sock->accept();
			$peerHost = $client->peerhost();
			$refs->{$client}      = $client;
			check4SSL($client); #upgrade to SSL whenever client likes to.
			$s->add($client);
			#if ($isSSLSock->{$sock}) {
			#	$isSSLSock->{$client} = 1;
			#}
			if ($sock->sockport() == 20) { #assume it's ftp data channel
				$ftpDataSock = $client;
				next;
			}
			initState4Sock($client);
			print "$client|$sock2module->{$client}\n";
			sequence($client, $CONNECT);
		} elsif ($meteSock eq $sock) { #can be used for metepreter
			$buff = "";
			sysread($sock, $buff, 0x100000);
			$len = length($buff);
			#print "len=$len\n";
			if ($len <= 0) {
				$s->remove($meteSock);
				close $sock;
				$recvedMetepreterData = 0;
				next;
			}
			$recvedMetepreterData = 1;
			handleMeteSock();
		} elsif ($sock->sockport() == 20) {
			
			$buff = readSock($sock);
			if (length($buff) <= 0) {
				$s->remove($sock);
				close $sock;
			}
		} else {
			$dataBuf = readSock($sock);
			if (length($dataBuf) <= 0) {
				$s->remove($sock);
				delete $refs->{$sock};
				delete $ctx->{$sock};
				delete $isSSLSock->{$sock};
				close $sock;
				next;
			}
			if ((time() - $lastTS) > 5) {
				if ($debug == 1) { print "here\n"}
			} else {
				$lastTS = time();
			}
			sequence($sock, $DATA, $dataBuf);
			if ($#pendingActions >= 0) {
				#printf "count of pending actions %d\n", $#pendingActions;
				$action = shift @pendingActions;
				execute($action);
			}
		}
	}
}
sub initState4Sock {
	my $sock = shift;
	$sock2module->{$sock} = dclone($port2module->{$sock->sockport()});
	$sock2module->{$sock}->{httpState} = {data => "", fullHttp => 0, hasHeader=>0};
}
sub readSock {
	my $sock = shift;
	my $buff = "";
	if (defined $isSSLSock->{$sock}) {
		sysread($sock, $buff, 0x1000000);
		if ($showData) { printf("recved: $buff\n");}
	} else {
		sysread($sock, $buff, 0x100000);
	}
	return $buff;
}
sub checkDelayedJob {
	if ($lastTs != 0.0) {
		my $tmp = getTS();
		#printf("time elapsed %f\n", $tmp-$lastTs);
		if ( ($tmp - $lastTs) >= 1.0) {
			if ($recvedMetepreterData == 0) {
				print "sending >> to start with simple session\n";
				$meteSock->send(">>");
				$meteState = 1; 
			}
			$lastTs = 0.0;
		}
	}
}
sub processCmd {
	my ($cmd, $option) = @_;
	$cmd =~ s/^\s*//;
	my @a = split(/\s+/, $cmd);
	my @b;
	my $module;
	if ($a[0] =~ /^act/) { #activate
		$savedActCmd = $cmd;
		$pattern = $a[1];
		if (defined $option) { goto only1choice;}
		foreach $e (keys %$allServices) {
			if ($e =~ /$pattern/) {
				push @b, $e;
			}
		}
		if ($#b < 0) { 
			print "didnot find a match\n";
			return;
		} elsif ($#b > 0) {
			print "multiple entries found, please make a choice by number:\n";
			$tmp = 1;
			foreach $e (@b) {
				printf "%2d $e\n", $tmp ++;
			}
			chomp($tmp = <STDIN>);
			$module = $allServices->{$b[$tmp-1]};
		} else {
only1choice:
			$module = $allServices->{$pattern};
		}
		my $ports2open = {};
		if (defined $a[2]) {
			for ($i=2; $<=$#a; $i++) {
				$port2module->{$a[$i]} = $module;
				$ports2open->{$a[$i]} = 1;
				#setupSocket($port);
			}
		} else {
			foreach $port (@{$module->{defaultPort}}) {
				$port2module->{$port} = $module;
				$ports2open->{$port} = 1;
			}
		}
		setupSocket($ports2open);
	} elsif (($a[0] eq "ls") || ($a[0] eq "list")) {
		foreach $e (keys %{$cfg->{$port}}) {
			if (defined $keyFields->{$e}) { next;}
			print "	$e\n";
		}
	} elsif ($a[0] eq "show") {
		$port = $a[1];
		print "$port is serviced by $port2module->{$port}->{name}\n";
	} elsif ($a[0] eq "reload") {
		readCfg();
		print "reloaded cfg\n";
	}
	print ">>";
}

sub handleMeteSock {
	#my $sock = shift;
	$isTlv = 0;
	if ($meteState == 1) { #simple
		chomp($buff);
		$tmp = `$buff`;
		$meteSock->send($tmp . ">>");
		return;
	}
	$accumBuf .= $buff;
	my $len = length($accumBuf);
accumBufTryAgain:	
	if ($len < 4) {
		return;
	} 
	#TODO need to look at the bytes in details
	$accumBuf = substr($accumBuf, $len+4);
	$len = length($accumBuf);
	if ($len == 0) { return; }
	goto accumBufTryAgain;
}
sub extraProc {
	my ($data, $extraParam) = @_;
	if (! defined $extraParam) { return;}
	if ($extraParam eq "saveHttpBody") {
		if ($data =~ /\r\n\r\n/) {
			print "saving...\n";
			$saved = $';
		} else {
			$saved = "";
		}
	}
}
sub sequence {
	my ($sock, $type, $data) = @_;
	my $seq = $sock2module->{$sock}->{seq};
	my $pattern;
	my $i;
	my $cmd;
	my $isNot;
	my $row;
	if (! defined $ctx->{$sock}) { $ctx->{$sock} = 0;}
	my $initMsg = $sock2module->{$sock}->{initMsg};
	if ($type == $CONNECT) {
		if (defined $initMsg) {
			sendit($sock, compact($sock, $initMsg));
		}
	} else {
		my $len = scalar @$seq;
		#printHex($data, 32);
		for ($i=0; $i<$len; ) {
			$pattern = compact($sock, [$seq->[$i]->[1]]);
			#print "debug $seq->[$i]->[0] $pattern\n";
			#printHex($pattern,32);
			$row = $seq->[$i];
			#print Dumper($row);
			$cmd = $seq->[$i]->[0]; $isNot = 0;
			if (substr($cmd,0,1) eq "!") {
				$cmd = substr($cmd, 1);  $isNot = 1;
			}
			if ($cmd eq "regex") {
				#$pattern = $seq->[$i]->[1];
				if ($data =~ /$pattern/) {
					#print "match again regex $pattern|$1|\n";
					$results[1] = $1;
					$results[2] = $2;
					$results[3] = $3;
					extraProc($data, $seq->[$i]->[2]);
					return sendit($sock, compact($sock, $seq->[$i+1]));
				}
			} elsif ($cmd eq "substr") {
				if (index($data, $pattern) >= 0) {
					extraProc($data, $seq->[$i]->[2]);
					return sendit($sock, compact($sock, $seq->[$i+1]));
				}
			} elsif ($cmd eq "starts") {
				#print "got here $pattern\n";
				if (index($data, $pattern) == 0) {
					extraProc($data, $seq->[$i]->[2]);
					return sendit($sock, compact($sock, $seq->[$i+1]));
				}
			} elsif ($cmd eq "equal") {
				if ($data eq $pattern) {
					extraProc($data, $seq->[$i]->[2]);
					return sendit($sock, compact($sock, $seq->[$i+1]));
				}
			} elsif ($cmd eq "split") {
				@results = split($seq->[$i]->[1], $data);
				#print Dumper(\@results);
				extraProc($data, $seq->[$i]->[2]);
				return sendit($sock, compact($sock, $seq->[$i+1]));
			} elsif ($cmd eq "any") {
				extraProc($data, $seq->[$i]->[2]);
				return sendit($sock, compact($sock, $seq->[$i+1]));
			} elsif ($cmd eq "http.response") {
				return sendit(composeHttpResponse($sock, $seq->[$i]->[1]));
			} 
			else { #handle some special commands
				if ($cmd eq "config") {
					configParam($row->[1]);
					$i ++;
					next;
				} elsif ($cmd eq "verifyCookie") {
					$result = isCookieValid($sock);
				} elsif ($cmd eq "isHttp") {
					#$sock2module->{$sock}->{httpState}->{data} .= $data;
					if ($debug == 1) {print "$sock|$sock2module->{$sock}\n";}
					$result = isHttp($sock2module->{$sock}->{httpState}, $data);
				} elsif ($cmd eq "in") {
					$value = evaluateExpression($sock, $row->[1]);
					print "in value=$value\n";
					$result = 0;
					foreach $tmp (@{$row->[2]}) {
						if ($value eq $tmp) { $result = 1; }
					}
					if ($result) {
						return sendit($sock, compact($sock, $seq->[$i+1]));
					}
				} elsif ($cmd eq "else") {
					$result = 1;
				} elsif ($cmd eq "match") { #this command assume the second element is an variable.
					$value = evaluateExpression($sock, $row->[1]);
					#print "matching: result=$result\n";
					if ($row->[2] eq "==") {
						$result = ($value eq $row->[3])? 1 : 0;
					} elsif ($row->[2] eq "=~") {
						$tmpPattern = $row->[3];
						$result = ($value =~ /$tmpPattern/)? 1 : 0;
					} elsif ($row->[2] eq ">") {
						$result = (index($value, $row->[3]) >= 0)? 1 : 0;
					} else {
						die "operator $row->[2] not supported\n";
					}
				}
				if ($isNot) { $result = 1 - $result; }
				if ($result) {
					return sendit($sock, compact($sock, $seq->[$i+1]));
				}
			}
			$i += 2;
		}
		printf "can't find a match for request $data of size %d\n", length($data);
	}
	$ctx->{$sock} ++;
}

sub configParam {
	$globConfig = shift;
}


sub isCookieValid { #will get 
	my $sock = shift;
	my $cookie = getCookie($sock); #get a particular cookie, emusessid=<number>
	if ($cookie eq "") {
		$cookie = getTS();
		$sock2module->{$sock}->{httpState}->{cookie} = $cookie;
		$sessions->{$cookie} = {verified => 0};
		return 0;
	}
	my $sess = $sessions->{$cookie};
	if (! defined $sess) { return 0; }
	return $sess->{verified};
}

sub getCookie { #get a particular cookie, emusessid=<number>
	my $sock = shift;
	my $httpState = $sock2module->{$sock}->{httpState};
	my $line;
	print "getCookie()\n";
	for $line (split(/\n/,  $httpState->{header})) {
		if ($line =~ /Cookie:.*emusessid=([\d\.]+)/) {
			$httpState->{cookie} = $1;
			if (! defined $sessions->{$1}) {
				$sessions->{$1} = {verified => 0};
			}
			print "return from getCookie: $1 for sock=$sock\n";
			return $1;
		}
	}
	$tmp = getTS();
	$httpState->{cookie} = $tmp;
	$sessions->{$tmp} = { verified => 0};
	#print "add cookie for sock $sock\n";
	return "";
}
sub getUri {
	my $sock = shift;
	my $httpState = $sock2module->{$sock}->{httpState};
	#print Dumper($httpState);
	#print "$httpState->{header}|\n";
	if ($httpState->{header} =~ /^\S+\s(\S+)/) {
		return $1;
	}
	return "";
}
sub getBasicAuth {
	my $sock = shift;
	my $httpState = $sock2module->{$sock}->{httpState};
	my $line;
	for $line (split(/\n/,  $httpState->{header})) {
		if ($line =~ /Authorization: Basic\s+(\S+)/) {
			return decode_base64($1);
		}
	}
	return "";
}

sub evaluateExpression {
	my ($sock, $expr) = @_;
	#print $expr, "|\n";
	my $func = $param2func->{$expr};
	if (! defined $func) {
		die "Failed to find parameter $expr\n";
	}
	return $func->($sock);
}

sub mergeParam {
	my ($dst, $src) = @_;
	my $e;
	foreach $e (keys %$src) {
		$dst->{$e} = $src->{$e};
	}
}

sub composeHttpResponse {
	my ($sock, $param) = @_;
	my $http = dclone($globConfig->{http});
	mergeParam($http, $param);

	my $msg = "HTTP/1.1 ";
	if (defined $http->{responseCode}) {
		$msg .= $http->{responseCode};
		if ($http->{responseCode} =~ /^3/) {
			$msg .= " Moved";
		} else {
			$msg .= " other";
		}
	} else {
		$msg .= "200 OK";
	}
	$msg .= "\r\n";
	foreach $hdr (keys %$knownHeaders) {
		if (defined $http->{$hdr}) {
			$msg .= "$knownHeaders->{$hdr}: $http->{$hdr}\r\n";
		}
	}
	if ($sock2module->{$sock}->{httpState}->{cookie} eq "") {
		if ($debug == 1) { print "unexpected here\n"; }
		$tmp = getTS();
		$sock2module->{$sock}->{httpState}->{cookie} = $tmp;
		$sessions->{$tmp} = {verified => 0};
	}
	$msg .= "Set-Cookie: emusessid=" . $sock2module->{$sock}->{httpState}->{cookie} . ";\r\n";
	if (defined $http->{body}) {
		if (ref($http->{body}) eq "ARRAY") {
			my $value = compact($sock, [$http->{body}]);
			$msg .= "Content-Type: $ctype\r\n";
			$msg .= sprintf("Content-Length: %d\r\n", length($value));
			$msg .= "\r\n$value";
		} else {
			$msg .= sprintf("Content-Length: %d\r\n", length($http->{body}));
			$msg .= "\r\n$http->{body}";
		}
	} else {
		$msg .= "Content-Length: 0\r\n\r\n";
	}
	sendit($sock, $msg);
	initState4Sock($sock);
	return "";
}

sub isHttp {
	my ($httpState, $data) = @_;
	if ($httpState->{fullHttp}) {
		$httpState->{data} = "";
		$httpState->{fullHttp} = 0;
		$httpState->{hasHeader} = 0;
	}
	$httpState->{data} .= $data;
	if ($httpState->{hasHeader} != 1) {
		$tmp = index($httpState->{data}, "\r\n\r\n");
		if ($tmp < 0) { return 0;}
		$httpState->{header} = substr($httpState->{data}, 0, $tmp);
		$httpState->{data} = substr($httpState->{data}, $tmp+4);
		if ($httpState->{header} =~ /Content\-Length: (\d+)/) {
			$httpState->{clen} = $1;
		} elsif(index($httpState->{header}, "GET") == 0)  {
			$httpState->{clen} = 0;
		} else {
			die "unexpected http req $httpState->{header}\n";
		}
		$httpState->{hasHeader} = 1;
	}
	if (length($httpState->{data}) == $httpState->{clen}) {
		return 1;
	}
	return 0;
}



sub printHex {
	my ($x, $size) = @_;
	my @a = unpack("C*", $x);
	my $i;
	if (($size == 0) || ($size > $#a)) {
		$size = $#a;
	}
	for ($i=0; $i<=$size; $i++) {
		printf "%02x ", $a[$i];
		if (($i %16) == 15) { print "\n";}
	}
	if (($i % 16) != 15) {print "\n";}
}

sub evaluateString {
	my ($sock, $tmp) = @_;
	my $newExp;
	while (1) {
		if ($tmp =~ /\$(\d)/) {
			$newExp .= $` . "\$results[$1]";
			$tmp = $';
		} elsif ($tmp =~ /\$\{(.*?)\}/) {
			$newExp .= $` . evaluateExpression($sock, $1);
			$tmp = $';
		} else {
			last;
		}
	}
	$newExp .= $tmp;
	return $newExp;
}

sub compact {
	my ($sock, $a, $skips) = @_;
	my $ret;
	my $e;
	my $len;
	my $value = "";
	my $offset;
	my $pending = -1;
	my $j;
	my $cmd;
	my $i;
	if (! defined $skips) { $skip = 0; }
	for ($i=0; $i < (scalar @$a); $i++) {
		$e = $a->[$i];
		if ($skips > 0) {$skips --; next;}
		if ((ref $e) eq "HASH") {
			next;
		}
		if ((ref $e->[0]) eq "ARRAY") {
			$value .= compact($sock, $e);
		} elsif (ref($e) eq "") {
			if ($e eq "\$http.reply") {
				composeHttpResponse($sock, $a->[1]);
				$value = "";
			} elsif ($e eq "\$authenticate") {
				authenticate($sock);
				$value = "";
			} elsif ($e eq "\$sub") {
				$sock2module->{$sock}->{seq} = $a->[1];
				return sequence($sock, $DATA, "");
			} elsif ($e eq "skip") {
				return "";
			} else {
				$value = $e;
			}
		} elsif ($e->[0] eq "") {
			#nothing to do
		} elsif ($e->[0] eq "repeat") {
			$cnt = $e->[2];
			$value = $e->[1] x $cnt;
		} elsif ($e->[0] eq "nsize") {
			$offset = length($ret);
			$pending = $e->[1];
			next;
		} elsif ($e->[0] eq "crc32") {
			#print "calling crc on |$e->[1]|$results[0]|\n";
			$value = sprintf("%x", crc32(substr($e->[1], 0, $results[0])));
		} elsif ($e->[0] eq "action") {
			#print "got an action\n";
			for ($j=1; defined $e->[$j]; $j++) {
				push @pendingActions, $e->[$j];
			}
			next;
		} elsif ($e->[0] eq "eval") {
			#print Dumper($e);
			my $newExp = evaluateString($sock, $e->[1]);
			#print "$newExp\n";
			eval ("\$value = \"" . $newExp . "\"");
		} elsif ($e->[0] eq "file") {
			$value = evaluateString($sock, $e->[1]);
			if ($debug == 1) { print "filename=$value\n";}
			$value = readFile($value);
		} elsif ($e->[0] eq "append") {
			$value = compact($sock, $e, 1);
		} elsif ($e->[0] eq "saved") {
			$value = $saved
		} elsif ($e->[0] eq "function") {
			$value = &{$e->[1]}();
		} elsif ($e->[0] eq "gzip") {
			$value = "";
			$tmp = $e->[1];
			gzip \$tmp => \$value;
		} elsif ($cmd eq "skip") {
			return "";
		} elsif ($e->[0] =~ /^auth/) {
			authenticate($sock);
			$value = "";
		} elsif ($e->[0] eq "\$http.reply") {
			return composeHttpResponse($sock, $e->[1]);
		} elsif ((ref $e) eq "HASH") { #this part is not supported any more
			if (defined $e->{connect}) {
				connectTo($e->{connect});
			} elsif (defined $e->{sendFile}) {
				sendFileData($ftpDataSock, $e->{sendFile});
				if ($lastSock ne "") {sendit($lastSock, "200 transfer complete\r\n");}
				$sendFile = $e->{sendFile};
				$lastSock = $sock;
			}
			next;
		} elsif ($e eq "\$http.reply") {
			$value = composeHttpResponse($sock, $a->[1]);
			$value = "";
		} else {
			print "unexpected cmd: ";
			print Dumper($e);
			die "";
		}
		if ($pending > 0) {
			$pending --;
			if ($pending == 0) {
				substr($ret, $offset, 0) = length($value);
			}
		}
		$ret .= $value;
	}
	return $ret;
}

sub authenticate {
	$sock = shift;
	print "authenticate for sock=$sock\n";
	my $cookie = $sock2module->{$sock}->{httpState}->{cookie};
	if ($cookie eq "") {
		print "unexpected cookie null\n";
	}
	$sessions->{$cookie}->{verified} = 1;
}


sub readCfg {
	open FD, "service.cfg" || die "Failed to open service.cfg $!\n";
	read FD, $buff, 0x100000;
	close FD;
	my $follow;
	my $mod;
	try {
		$allServices = decode_json($buff);
		foreach $e (keys %$allServices) {
			$allServices->{$e}->{name} = $e;
			$follow = $allServices->{$e}->{follow};
			if (defined $follow) {
				$mod = dclone($allServices->{$follow});
				splice @{$mod->{seq}}, 0,0, @{$allServices->{$e}->{seq}};
				if (defined $allServices->{$e}->{initMsg}) {
					$mod->{initMsg} = $allServices->{$e}->{initMsg};
				}
				$mod->{name} = $e;
				$allServices->{$e} = $mod;
			}
		}
	} catch {
		print "Failed to decode json $_\n";
		return;
	};
	if ($savedActCmd ne "") {
		processCmd($savedActCmd);
	}
}

sub connectTo {
	my $dst = shift;
	my ($dstHost, $port) = split(/:/, $dst);
	if ($dstHost eq "") {
		$dstHost = $peerHost;
		#print "dstHost is now $dstHost\n";
	}
	$meteSock = IO::Socket::INET->new( Proto    => 'tcp',
                                 PeerAddr => $dstHost,
                                 PeerPort => $port
                          ) || die "Failed to connect to $dstHost:$port\n";
	$meteState = 0;
	$s->add($meteSock);
	print "metepreter is connected $meteSock\n";
	$lastTs = getTS();
	return $meteSock;
}

sub readFile {
	my $fname = shift;
	my $buff;
	if ($fname =~ /\/$/) { $fname .= "index.html"; }
	if (open (FD, $fname)) {
		read(FD, $buff, 0x1000000);
		close FD;
	} else {
		print "didnto find file fname=$fname $!\n";
		$buff = "didnot find file fname=$fname";
	}
	if ($fname =~ /\.([^\.]+)$/) {
		$ctype = $contentTypes->{$1};
	} else {
		$ctype = "text/html";
	}
	return $buff;
}
sub sendFileData {
	my ($sock, $fname) = @_;
	my $buff;
	if (open (FD, $fname)) {
		read(FD, $buff, 0x1000000);
		close FD;
	} else {
		print "didnto find file $fname $!\n";
		$buff = "didnot find file $fname";
	}
	sendit($sock, $buff);
}

sub execute {
	my $a = shift; #action
	try {
		if ($a->[0] eq "connect") {
			#TODO it's not always proper to use ftpDataSock here
			$ftpDataSock = $sock = connectTo($a->[1]);
		} elsif ($a->[0] eq "sendFile") {
			sendFileData($ftpDataSock, $a->[1]);
		} elsif ($a->[0] eq "send") {
			sendit($sock, $a->[1]);
		}
	} catch {
		warn "caught error: $_"; 
	}
}

sub sendit {
	my ($sock, $data) = @_;
	if ($data eq "") {
		#print "skipped sending empty data\n";
		return;
	}
	if ($data =~ /^HTTP\/1\.\d\s+/) {
		my $offset = index($data, "\r\n\r\n");
		if ($offset > 0) {
			my $bodyLen = length($data) - $offset - 4;
			my $header = substr($data, 0, $offset);
			my $body = substr($data, $offset);
			my $pattern = "Content-Length: $bodyLen";
			$header =~ s/Content-Length:\s*\$/$pattern/;
			$data = $header . $body;
		}
	}
	if (length($sock) <= 0) {
		print "closing socket since there is no data to send\n";
		$s->remove($sock);
		delete $refs->{$sock};
		delete $ctx->{$sock};
		delete $isSSLSock->{$sock};
		close($sock);
		return;
	}
	if ($showData) {print "sending $_[1]\n";}
	syswrite($sock, $data);
}

use Time::HiRes qw( gettimeofday );
sub getTS {
	my ($seconds, $microseconds) = gettimeofday;
	return $seconds + (0.0+ $microseconds)/1000000.0;
}

#set up a bunch of sockets
sub setupSocket {
	my $ports = shift;
	my $port;
	my $sock1;
	foreach $port (keys %$srvSocks) {
		$sock1 = $srvSocks->{$port};
		if (! defined $ports->{$port}) {
			$s->remove($sock1);
			delete $srvSocks->{$port};
			delete $isSrvSock->{$sock1};
			close($sock1);
		}
	}
	my $sock1;
	foreach $port (keys %$ports) {
		if (defined $srvSocks->{$port}) { next;}
		print "listening on port $port\n";
		$sock1 = IO::Socket::INET->new( Proto    => 'tcp',
									 LocalAddr => $lhost,
									 LocalPort => $port,
									 Reuse     => 1,
									 Listen    => 10
							  ) || die "Failed to bind to port $port\n";
		$srvSocks->{$port} = $sock1;
		$isSrvSock->{$sock1} = 1;
		$s->add($sock1);
	}
}

sub check4SSL {
	my $client = shift;
	$buffer = "";
	$s2->add ($client);
	@readySocks = $s2->can_read(0.5);
	$s2->remove ($client);
	if ($#readySocks < 0) { return; }
	recv($client, $buffer, 1000, MSG_PEEK );
	if (length($buffer) < 100) {return;}
	@a = unpack("C*", $buffer);
	#print "first byte: $a[0]\n";
	if (($a[0] != 22) || ($a[1] != 3) || ($a[2] > 3)) { 
		#print "not SSL $a[0]|$a[1]|$a[2]\n";
		return;}
	#print "start SSL\n";
	if (! IO::Socket::SSL->start_SSL( $client,
		SSL_server => 1,
		Timeout => 5,
		SSL_version => 'TLSv1',
		SSL_cert_file => 'certs/server-cert.pem',
		SSL_key_file => 'certs/server-key.pem',
	)) {
		print "SSL Handshake FAILED - $!\n";
		return;
	}
	$isSSLSock->{$client} = 1;
}
sub input_thread {
	my $tmp;
	while (<STDIN>) {
		chomp($tmp = $_);
		$threadVar = $tmp;
	}
}

#overcome the problem where on windows, $s->can_read(0.5) will return immediately if $s is empty
sub mySelect {
	my $timeout = shift;
	if ($s->count() == 0) {
		select (undef, undef, undef, $timeout);
		return ();
	} else {
		return $s->can_read($timeout);
	}
}
